;;;;;;;;;;;;;;;;;;;;;;
;;;Diffusion Model;;;;
;;;;;;;;;;;;;;;;;;;;;;

to go
 ;; if no-new-adoption? [stop]
  
  if all? turtles [not active?]  [ stop ]   ;; it will stop when there is no more active turtles
  
  ;reset-roundActiveCounts
  reset-weight-sums
  reset-consider ;this is commented out
  reset-payoffs
  
  propagate-influence
  
  ;update-remaining-duration                 ;; sets new remaining-durations for new behaviors present in network_dynamics.nls
                           
  update-threshold                          ;; set the new threshold if the threshold switch is on  
  ;update-costs                              ;; set the new cost
  
  
  
  make-adoption-decision
  
  set-turtle-color
  
 
  update-indicators

  
  tick
end

to-report no-new-adoption?
  let new-adoption reduce + array:to-list roundActiveCounts
  ifelse new-adoption = 0
  [report true]
  [report false]
end 

to reset-roundActiveCounts
  set roundActiveCounts array:from-list all-zeros
end

to reset-weight-sums
  ask turtles [
    set weight-sums array:from-list all-zeros
  ]
end

to reset-consider
  ask turtles [
    foreach behav-id-list [
      ;ifelse duration-model = "none"[
      ;array:set consider? ? (array:item actives? ?)   ;; previously adopted behaviors are automatically considered
     ; ][
      array:set consider? ? false ; only behaviors crossing the threshold are considered
      ;]
    ]
  ]
end

to reset-payoffs
  ask turtles [
    set payoffs array:from-list all-zeros
  ]
end    



to propagate-influence 
  ask turtles [
    foreach behav-id-list [
      if array:item actives? ?
      [
        ask my-links [
          influence myself ?
          ;set color (base + ? * step)
        ]
      ]
    ]
  ]
end

;; link procedure; influencer influences the other end of the link; link procedure
to influence [influencer behav-id]
  calculate-weight-sums influencer behav-id
end

;; decision to turn active or not
to make-adoption-decision
  ask turtles [
    calculate-payoffs
    
    calculate-high-local-influence
    
    run update-turtle-attr
    
    run new-consider
    
    let opt knapsack-decide
    
    foreach opt [
     array:set actives? ? true
     (run after-adoption ?)
    ]
    
  ]
end

to calculate-high-local-influence
  foreach behav-id-list [
    if array:item weight-sums ? >= array:item thresholds ? [
      array:set consider? ? true
    ]
  ]
end
    

;; turtle procedure for adoption decision making
;; employs brute-force search for the knapsack problem
;; ; should implement dynamic programing version of the knapsack algorithm
to-report knapsack-decide 
  let consider-behav-list filter [array:item consider? ?] behav-id-list
  
  let power-set compute-power-set consider-behav-list
  
  let opt [] 
  let max-payoff 0
  foreach power-set [
    let total-cost 0
    foreach ? [
      set total-cost total-cost + (array:item costs ?)
    ]
    if total-cost <= remaining-resource [  ;; resource minus the used-resource because the used-resource is sticky  
      let total-payoff 0
      foreach ? [
        set total-payoff total-payoff + (array:item payoffs ?)
      ]
      if total-payoff > max-payoff [
        set max-payoff total-payoff
        set opt ?
      ]
    ]
  ]
  
  report opt
end

to-report compute-power-set [list-of-items]
;  ifelse empty? list-of-items [
;    report [[]]
;  ]
;  [
;    let head first list-of-items
;    let rest but-first list-of-items
;   let rest-power-set compute-power-set rest
;    let new-subsets []
;    foreach rest-power-set [
;      set new-subsets sentence new-subsets (list (sentence ? head))
;   ]
;    report sentence rest-power-set new-subsets
;  ]
  
  report compute-power-set-tail-recursive [[]] list-of-items
end

to-report compute-power-set-tail-recursive [list-of-subsets list-of-items]
  ifelse empty? list-of-items [
    report list-of-subsets
  ]
  [
    let head first list-of-items
    let list-of-new-subsets map [sentence ? head] list-of-subsets
    report compute-power-set-tail-recursive (sentence list-of-subsets list-of-new-subsets) (but-first list-of-items)
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;Auxiliary Procedures;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; turtle procedure
;; turtle procedure
to set-color
;;  set color 0
;;  let num 0
  
;;  foreach behav-id-list [
;;    if array:item actives? ? [
;;     set color color + (base + ? * step)
;;      set num num + 1
;;    ]
;;  ]
;;  if num > 1 [
;;   set color color + scaling
;;  ]

  ifelse active? [
    set color base
  ]
  [
    set color neutral
  ]
end
  

;; turtle procedure
to-report active?
  foreach behav-id-list [
    if array:item actives? ? [
      report true
    ]
  ]
  report false
end